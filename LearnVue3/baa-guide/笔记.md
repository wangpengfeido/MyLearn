## VUE3的改变

### 组合式API

#### 动机与目的

##### 更好的逻辑复用与代码组织
Vue2是通过选项组织代码，这有两个缺点：
1. 随着功能的增长，复杂组件的代码变得越来越难以阅读和理解。因为代码是通过选项而非逻辑组织的。
2. 缺少简洁且低成本的机制来提取和重用多个组件之间的逻辑。

组合式API解决了这两个问题。

##### 更好的类型推导
Vue2使用this来暴露property，这使得类型推导困难。

组合式API利用了天然对类型友好的普通变量与函数。

#### 设计细节

##### 代码组织
我们去理解一段代码时，我们更加关心的是这个组件是要干什么，而非组件用了什么选项。

如果我们将处理的某个逻辑定义为逻辑关注点。在大型组件中通常会存在多个逻辑关注点，而Vue2每个逻辑关注点的代码又是分散在不同的选项中的，这使理解和维护代码变得困难。

组合式API可以将相关的逻辑封装在一个函数中，这样的函数我们习惯以use开头，并称其为组合函数。steup函数作为组合函数的入口。这样，steup函数就像在口述这个组件在做什么，并且，可以通过参数传递清楚地明白函数之间的依赖关系。

##### 逻辑提取与复用
可以将任何一段逻辑封装为组合函数来复用。

它的好处是：
* 暴露给模板的 property 来源十分清晰，因为它们都是被组合逻辑函数返回的值。（相比mixin）
* 不存在命名空间冲突，可以通过解构任意命名。（相比mixin）
* 不再需要仅为逻辑复用而创建的组件实例。（相比作用域插槽无渲染组件）

##### 与现有 Vue2 API 配合
* 组合式 API 会在 2.x 的选项 (data、computed 和 methods) 之前解析，并且不能提前访问这些选项中定义的 property。
* setup() 函数返回的 property 将会被暴露给 this。它们在 2.x 的选项中可以访问到。

##### 插件开发
很多Vue2的插件向this注入了property，例如this.$route.使用组合式API不再利用this，而是使用provide和inject。

#### 弊端
##### 引入 Ref 的心智负担
1. 需要一直区别“响应式值引用”与普通类型的值与对象。这可以通过特殊名称规范或类型系统来解决。
2. 如些ref比普通值更冗余。

为什么必须要引入ref：
1. 计算值的getter可以返回基础类型值。
2. 一些组合函数只接收或返回基础类型值，它们也需要被包裹成为一个对象才能够保持其响应性。

##### Ref vs. Reactive
这可以根据代码风格来确定。

但是注意，使用reactive时，必须保持对它的引用，对其解构或展开将失去其响应性。这可以通过 toRefs API 解决。

##### setup 返回语句冗长
明确的返回语句对可维护性是有益的。

##### 更多的灵活性来自更多的自我克制
组合式API容易导致写出面条代码

#### 与 React Hooks 比较
与 React Hooks 相比，响应式 API 的 setup() 只调用一次，这意味着：

* 更符合惯用的 javascript 直觉。
* 不需要顾虑调用顺序，也可以用在条件语句中。
* 不会在每次渲染时重复执行，降低了垃圾回收的压力。
* 不存在内联处理函数导致子组件永远更新的问题，也不需要 useCallback。
* 不存在忘记记录依赖的问题，也不需要“useEffect”和“useMemo”并传入依赖数组以捕获过时的变量。Vue 的自动依赖跟踪可以确保侦听器和计算值总是准确无误。

